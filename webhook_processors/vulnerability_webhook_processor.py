import hmac
import hashlib
import time
import json
from typing import cast

from loguru import logger
from port_ocean.context.ocean import ocean
from port_ocean.core.handlers.webhook.abstract_webhook_processor \
    import AbstractWebhookProcessor
from port_ocean.core.handlers.webhook.webhook_event import (
    EventHeaders,
    EventPayload,
    WebhookEvent,
    WebhookEventRawResults,
)
from port_ocean.core.handlers.port_app_config.models import ResourceConfig
from initialize_client import create_aikido_client
from integration import VulnerabilityResourceConfig
from kinds import Kinds


class VulnerabilityWebhookProcessor(AbstractWebhookProcessor):
    async def should_process_event(self, event: WebhookEvent) -> bool:
        et = event.payload.get("event_type", "")
        return et.startswith("issue.")

    async def get_matching_kinds(self, event: WebhookEvent) -> list[str]:
        return [Kinds.VULNERABILITY]

    async def authenticate(
            self,
            payload: EventPayload,
            headers: EventHeaders
    ) -> bool:
        # HMAC secret from your integration config
        secret = ocean.integration_config.get("hmac_signing_secret")
        signature = headers.get("X-Aikido-Webhook-Signature", headers.get("x-aikido-webhook-signature"))

        if not secret or not signature:
            logger.warning("Missing HMAC secret or signature header")
            return False

        # Re‑serialize payload exactly as Aikido sent it
        raw_payload = json.dumps(payload, separators=(",", ":"), sort_keys=True)
        digest = hmac.new(
            secret.encode(),
            raw_payload.encode(),
            hashlib.sha256
        ).hexdigest()

        if not hmac.compare_digest(digest, signature):
            logger.warning("Webhook HMAC signature mismatch")
            return False

        # Prevent replay: dispatched_at must be within last 30s
        dispatched = payload.get("dispatched_at", 0)
        if time.time() - dispatched > 30:
            logger.warning("Stale webhook: dispatched_at too old")
            return False

        return True

    async def validate_payload(self, payload: EventPayload) -> bool:
        # Must include nested payload.issue_id
        inner = payload.get("payload", {})
        return isinstance(inner, dict) and "issue_id" in inner

    async def handle_event(
            self,
            payload: EventPayload,
            resource_config: ResourceConfig
    ) -> WebhookEventRawResults:

        config = cast(VulnerabilityResourceConfig, resource_config)
        sel = config.selector

        issue_id = payload["payload"]["issue_id"]
        status = payload["payload"]["status"]

        terminal_states = {"closed", "ignored"}

        if status in terminal_states or (
                sel.filter_status != "all" and status != sel.filter_status
        ):
            logger.info(f"Issue {issue_id} status '{status}' not in selector → deleting")
            return WebhookEventRawResults(
                updated_raw_results=[],
                deleted_raw_results=[{"id": issue_id}],
            )

        client = create_aikido_client()
        data = await client.get_issue(issue_id)
        return WebhookEventRawResults(updated_raw_results=[data],
                                      deleted_raw_results=[])
